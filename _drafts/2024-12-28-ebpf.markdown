---
layout: post
title: "eBPF"
date: 2024-12-28
categories: [Tech]
---

# BPF

Originally BPF was the abbreviation of Berkley Packet Processing, a small virtual machine running within the unix kernel designed to filter network packets on incoming interfaces. BPF allowed dynamic modifications of the filtering rules applied on the incoming packets giving power to the users for custom filtering criteria.

As technology progressed, particularly in the early 2010s, the Linux kernel became a dominant operating system for server-side computing. This stability led to challenges in innovating within the kernel without facing significant resistance. Key developers recognized limitations in the existing capabilities of the Linux kernel, regarding networking and observability, prompting them to extend BPF into what is now known as extended Berkley Packet Processing or eBPF today. The term eBPF should not be treated as an abbreviation but rather as the name of the technology itself, as having the name extended Berkley Packet Processing does not name much sense anymore.

They did not need to start from scratch as Linux kernels already had orignal BPF support, so what was done is to just extend the virtual machine to support a wider instruction set with more general operations and turning it into a more generelized virtual machine running inside the kernel that could be used not only for packet filtering but for far more, especially observability, security and more custom packet processing.

# eBPF

As mentioned eBPF is a virtual machine running inside the linux kernel. It has its own instruction set and registers. At the time of writing this article the eBPF VM has a total of 11 64bit general purpose registers named R0 up to R10, where different registers are used for different purposes following some specific conventions. The instruction set along with the meaning of each register can be looked up on [kernel.org](https://www.kernel.org/doc/html/v5.17/bpf/instruction-set.html)[^1] or simply by searching on the internet for eBPF instruction set.

The whole pipeline of executing eBPF programs is as follows, the eBPF program is written in the supported instruction set to achieve the desired behaviour, the program is then loaded into the kernel where it is verified before actually being executed. This step is important because running arbitrary programs inside the kernel is dangerous. Verification of the program is done by the verifier, which checks for every pointer access, infinite loops and generally prevents undefined behaviour that would crash the kernel. When loading arbitrary eBPF programs, the last thing we want is for the kernel to crash. Once the loading of the program passes the verification step, we have a guarantee that our program will not crash the kernel.

![alt text](/assets/img/ebpf/ebpf.png)

As you can see from the figure above, there are various events, namely kprobes, uprobes, tracepoints and perf events, to which the eBPF program can attach itself. Once the program is loaded into the kernel, it is not executed immediately, but on each occurrence of the given event.

In practice, eBPF programs are not written by hand with the instruction set (which is very similar to assembly), but there are already tools that we can use to speed up the development process. Clang is a C compiler based on LLVM that implements the BPF backend, meaning that we can write C code that we can then compile down to the instruction set of the eBPF virtual machine to run our programs. In addition, the eBPF ecosystem around the C language has a number of utilities that make working with eBPF much more pleasant, such as [libbpf](https://github.com/libbpf/libbpf)[^2].

Generally speaking, an eBPF binary, i.e. when the written program is compiled down to the VM executable, consists of more than just eBPF programs, there are also maps and also BTF (but more on that later). Maps are a way for eBPF programs to store state that can be carried over across multiple runs of the same program, or even to share data between different eBPF programs or even user space programs. As with the verifier, which would not allow arbitrary instructions to be executed within the kernel, maps also have a limitation in that they cannot hold infinite amounts of data, as we are used to when programming in userspace. Specific limits on the number of elements must be specified at compile time, and working with these limits will be one of the more difficult parts of writing eBPF programs, along with satisfying the verifier.

The main selling point of eBPF programs is that instead of writing kernel extensions, i.e. kernel modules, or recompiling the kernel with your own modifications, which could end up crashing the kernel if you are not very careful, you have this "safe" interface which can be used to deploy your modification much faster and safer.

Software development is an ongoing process that rarely, if ever, ends. As with previous options, such as the kernel module, the Linux kernel is constantly evolving, and type definitions within the kernel are subject to change in the future, directly affecting any custom extension we have provided for the current version. BPF programs are no exception.

When writing eBPF programs, you have access to the type definitions within the Linux kernel, which makes the development process much easier. When you develop the program, you compile it with respect to the current Linux version you are running, and thus with the kernel type definitions within that version, making it incompatible with newer or older kernel versions if the type definitions have changed. This is where Compile-Once Run-Everywhere (CO-RE) comes in.

# CO-RE

If you wanted to deploy your program on multiple machines, you would most likely have compatibility problems unless each machine was running the exact same version of the Linux kernel. So, to solve this problem, you would have to download dependency and compilation tools on each machine, and then compile and deploy the eBPF program on each of them individually, ugh!

Not only is this cumbersome, it is also error-prone and wastes a lot of computing resources. Compile-Once Run-Everywhere addresses these compatibility issues between different Linux kernel versions for a compiled eBPF program by using BTF.

BTF is a mechanism that carries the type definitions, field offsets within types, function signatures, etc. for a specific Linux kernel version. This type information is then included in the compiled eBPF binary itself and when deployed, the inconsistencies are dynamically resolved at run time by the eBPF virtual machine without requiring any changes to the program, allowing you to compile your eBPF program once locally on your machine and deploy it to different machines. You will see an example of that in the Hello-World section.

# Lifetime

BPF objects, maps, programs, etc. are managed by reference counting. Each time a map is created, its reference count is set to 1 and a file descriptor is returned to the calling user-space process. The returned file descriptor can then be used to interact with the map within the user-space process.

Similarly, when a bpf program is loaded, its reference count is set to 1 and a file descriptor is returned. Furthermore, when the bpf program uses a bpf map, the map is first created with a reference count of 1, and then increased again as the program itself references the map, resulting in the map remaining alive as long as the program is alive.

When the reference count for any bpf object reaches 0, it is aborted by the kernel and will not be executed again until it is loaded again.

In general, there are two ways to manage the lifecycle of an eBPF program. Run a user space process as long as the eBPF program needs to run, i.e. keep the file descriptor and thus the reference to the program/maps alive, or use pinning.

Pinning refers to a concept where we essentially "pin" the map or program to the file system and thus keep the reference to the bpf objects alive as long as the computer is running, and avoid problems with unwanted process terminations/restarts.

# Hello World
Lets build an hello world eBPF program that prints every usage of the openat syscall.

Setting up the development environment. To work with the kernel data structure without running into different kinds of collisions when importing header files, btftool[^3] provides useful utilities when working with eBPF programs including generating all the data structures used within the kernel that we can then import in our eBPF program.

```bash
$ sudo bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

Next we find the trace hook point for the openat syscall

```bash
$ sudo ls /sys/kernel/debug/tracing/events/syscalls/ | grep openat

>
sys_enter_openat
...
```

further we also can figure out the arguments with

```bash
sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format
name: sys_enter_openat
ID: 628
format:
	field:unsigned short common_type;	offset:0;	size:2;	signed:0;
	field:unsigned char common_flags;	offset:2;	size:1;	signed:0;
	field:unsigned char common_preempt_count;	offset:3;	size:1;	signed:0;
	field:int common_pid;	offset:4;	size:4;	signed:1;

	field:int __syscall_nr;	offset:8;	size:4;	signed:1;
	field:int dfd;	offset:16;	size:8;	signed:0;
	field:const char * filename;	offset:24;	size:8;	signed:0;
	field:int flags;	offset:32;	size:8;	signed:0;
	field:umode_t mode;	offset:40;	size:8;	signed:0;

print fmt: "dfd: 0x%08lx, filename: 0x%08lx, flags: 0x%08lx, mode: 0x%08lx", ((unsigned long)(REC->dfd)), ((unsigned long)(REC->filename)), ((unsigned long)(REC->flags)), ((unsigned long)(REC->mode))
```

The program will have two parts, the kernel-space and the user-space part. In order to exchange information between these two parts, a channel must be established with a common data structure that is known at compile time. We will create a file called `events.h` that will have the necessarity struct definitions.

```c
#ifndef EVENTS_H
#define EVENTS_H

#define MAX_COMM_LENGTH 32

struct event {
	char parent_comm[MAX_COMM_LENGTH];
	char requested_comm[MAX_COMM_LENGTH];
};

#endif
```

The next step is to write the kernel part of the eBPF program. The kernel contains much more code that we will look at in more detail. The kernel part file
will be named `hello-world.bpf.c`, note the `.bpf` to indicate that it is an bpf program written in C, not a regular user space program.

```c
#include "vmlinux.h"
#include "events.h"

#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

struct {
	__uint(type, BPF_MAP_TYPE_RINGBUF);
	__uint(max_entries, 1024);
} buffer SEC(".maps");

char LICENSE[] SEC("license") = "GPL";

SEC("tracepoint/syscalls/sys_enter_openat")
int openat(struct trace_event_raw_sys_enter *ctx) {
	struct event *event = bpf_ringbuf_reserve(&buffer, sizeof(struct event), 0);
	if (!event) {
		// failed to allocate memory for next event.
		return 0;
	}
	bpf_get_current_comm(&event->parent_comm, sizeof(event->parent_comm));
	bpf_probe_read_str(&event->requested_comm, sizeof(event->requested_comm), (void*)ctx->args[1]);
	bpf_ringbuf_submit(event, 0);
	return 0;
}
```

**NOTE:** the `SEC` macros you see in the kernel part of the eBPF program are sections that will be present within the compiled binary itself (we will come back to this later), we can use these section to identify which bpf objects are present in the binary.

1. The program starts by including the generated "vmlinux.h" will all necessary kernel data structures which we then reference in the eBPF program.
2. We define a map called `buffer` and give it a maximum of 1024 elements. Its type is `BPF_MAP_TYPE_RINGBUF`, which is a common mechanism to exchange
   data between the kernel and user-space part of the eBPF program. A ring buffer is a circular buffer where data is pushed and consumed from.

    ![alt text](/assets/img/ebpf/ringbuf.png)

   In this case the kernel part would be the producer and the user-space part the consumer of the ring buffer.

3. The license. Your eBPF program must specify a license. This depends on what your program needs to achieve and whether it needs the helper functions defined in the bpf library itself or not. If you use a GPL-licensed helper function, then your eBPF program itself must use the GPL license.

4. Finally, the eBPF program itself, which is attached to the `sys_enter_openat` syscall. The program itself is quite simple, we reserve memory in the ring buffer and then read the process name that is executing the `sys_enter_openat` syscall with `bpf_get_current_comm(&event->parent_comm, sizeof(event->parent_comm))` and the filename that is passed to the syscall as an argument with `bpf_probe_read_str(&event->requested_comm, sizeof(event->requested_comm), (void*)ctx->args[1])`. We then pass this data to the ring buffer to be processed in the user-space part of the eBPF program.

    **NOTE** that the filename is the second argument passed to the syscall, which we can also identify from the above information about the syscall dumped via `sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format`, thus `ctx->args[1]` is used within the eBPF program.

To wrap this up, we finish we the user-space part of the eBPF program.
# XDP - Hello World
explain what xdp is.

lifecycle of xpd programes attached to an interface will depend on the life of that interface.
TODO: add reference to xdp loadbalancer and include simple hello world example

# Future
TODO: Mentiond GPUs and windows.

# Conclusion

**Footnotes**

[^1]: [BPF - Instruction set, Accessed 28. Dec. 2024](https://www.kernel.org/doc/html/v5.17/bpf/instruction-set.html)
[^2]: [libbpf - Instruction set, Accessed 28. Dec. 2024](https://github.com/libbpf/libbpf)
[^3]: [bpftool, Accessed 28. Dec. 2024](https://github.com/libbpf/bpftool)
